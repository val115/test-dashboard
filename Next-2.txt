https://nextjs.org/learn/dashboard-app/getting-started

npm install -g pnpm
npx create-next-app@latest nextjs-dashboard --example "https://github.com/vercel/next-learn/tree/main/dashboard/starter-example" --use-pnpm
pnpm dev
 ----------

https://reactdev.ru/libs/nextjs/app-router/css-styling/#_2
Стили
Два разных способа стилизации: Tailwind и CSS-модули.
global.css. Этот файл можно использовать для добавления правил CSS для всех маршрутов в вашем приложении,
Вы можете импортировать global.css в любой компонент вашего приложения, но обычно рекомендуется добавлять его в компонент верхнего уровня. В Next. js
global.css, вы заметите некоторые @tailwind (Попутный ветер)  директивы:
В Tailwind вы стилизуете элементы, добавляя имена классов. Например, добавление "text-blue-500" сделает текст <h1> синим:
=======================
clsx Это библиотека,
https://github.com/lukeed/clsx

 которая позволяет легко переключать имена классов. Мы рекомендуем ознакомиться с документацией для получения более подробной информации, но вот базовый пример использования:
axemple (фактура) - app/ui/invoices/status.tsx
===============================
#cd nextjs-dashboard
Для этого проекта мы предоставили некоторые данные-заполнители в app/lib/placeholder-data.ts. Каждый объект JavaScript в файле представляет собой таблицу в вашей базе данных. Например, для таблицы счетов-фактур:
А пока взгляните на файл /app/lib/definitions.ts . Здесь мы вручную определяем типы данных, которые будут возвращаться из базы данных.
 Мы вручную указываем типы данных, но для большей безопасности рекомендуем использовать Prisma или Drizzle, которые автоматически генерируют типы на основе схемы вашей базы данных.
 ####################

Шрифты играют важную роль в дизайне сайта, но использование пользовательских шрифтов в вашем проекте может повлиять на производительность, файлы шрифтов должны быть получены и загружены.
Cumulative Layout Shift - это метрика, используемая Google для оценки производительности и удобства работы с сайтом
Next.js автоматически оптимизирует шрифты в приложении, когда вы используете
модуль next/font.
Он загружает файлы шрифтов во время сборки и размещает их вместе с другими статическими активами. Это означает, что когда пользователь посещает ваше приложение, не происходит дополнительных сетевых запросов к шрифтам, которые могут влиять на производительность.
Next.js загружает файлы шрифтов во время сборки и размещает их вместе с другими статическими активами. Это означает, что когда пользователь посещает ваше приложение, нет никаких дополнительных сетевых запросов к шрифтам, которые могли бы повлиять на производительность.
----------
В папке /app/ui создайте новый файл fonts.ts.
Импортируйте шрифт Inter из модуля next/font/google -
Затем укажите, какое подмножество вы хотите загрузить. В данном случае 'latin':
/app/layout.tsx
import '@/app/ui/global.css';
import { inter } from '@/app/ui/fonts';
<body  className={`${inter.className} antialiased`} >
класс Tailwind antialiased, который сглаживает шрифт. Использовать этот класс необязательно, но он добавляет приятный штрих.

Вы также можете добавить шрифты к определенным элементам вашего приложения.
В файле fonts.ts импортируйте вторичный шрифт Lusitana и передайте его элементу <p> в файле /app/page.tsx. В дополнение к указанию подмножества,  вы также должны указать различные веса шрифта. Например, 400 (нормальный) и 700 (жирный).
Наконец, компонент <AcmeLogo /> также использует Lusitana. Он был закомментирован для предотвращения ошибок, теперь его можно не комментировать:
##############

Next.js может обслуживать статические активы, такие как изображения, в папке верхнего уровня /public.
Однако это означает, что вам придется работать вручную:

1. Убедиться, что изображение реагирует на разные размеры экрана.
2. Задать размеры изображений для разных устройств.
3. Предотвратить смещение макета при загрузке изображений.
4. Ленивая загрузка изображений, которые находятся вне области просмотра пользователя.

Компонент <Image> является расширением тега HTML <img>
 включает в себя автоматическую оптимизацию изображений, такую как:
1. Предотвращение автоматического смещения макета при загрузке изображений.
2. Изменение размера изображений, чтобы избежать отправки больших изображений на     устройства с меньшей областью просмотра.
3. Ленивая загрузка изображений по умолчанию (изображения загружаются по мере их попадания в область просмотра).
4. Использование изображений в современных форматах, таких как WebP и AVIF, если браузер поддерживает их.
В файле /app/page.tsx импортируйте компонент из next/image. Затем добавьте изображение под комментарием:

import Image from 'next/image';

Вы также заметите класс hidden, чтобы убрать изображение из DOM на мобильных экранах, и md:block, чтобы показать его на настольных экранах.

Добавление основного изображения для мобильных устройств
Под основным изображением, которое вы только что добавили, добавьте еще один компонент <Image> для hero-mobile.png.
Это изображение должно иметь width в 560 и height в 620 пикселей.
Оно должно быть показано на мобильных экранах и скрыто на десктопе - вы можете использовать инструменты dev, чтобы проверить, правильно ли поменялись местами десктопные и мобильные изображения.

##########################

Создание макетов и страниц
Вы можете создавать отдельные пользовательские интерфейсы для каждого маршрута с помощью файлов layout.tsx и page.tsx.
page.tsx - это специальный файл Next.js, который экспортирует компонент React, и он необходим для того, чтобы маршрут был доступен.
/app/dashboard/page.tsx ассоциируется с путем /dashboard.
Благодаря специальному названию для файлов page Next.js позволяет размещать компоненты пользовательского интерфейса, тестовые файлы и другой связанный код вместе с маршрутами. Только содержимое внутри файла page будет общедоступным. Например, папки /ui и /lib размещаются внутри папки /app вместе с маршрутами.

В вашем дашборде создайте еще две страницы:
 Страница клиентов: Страница должна быть доступна по адресу - customers
  Страница счетов: Страница счетов должна быть доступна по адресу - invoices

Дашборды имеют некую навигацию, которая используется на нескольких страницах. В Next.js вы можете использовать специальный файл layout.tsx для создания пользовательского интерфейса, разделяемого между несколькими страницами. Давайте создадим макет для страниц дашборда!
Во-первых, вы импортируете компонент <SideNav /> в ваш макет. Все компоненты, которые вы импортируете в этот файл, будут частью макета.
Компонент <Layout /> получает свойство children. Этим дочерним компонентом может быть либо страница, либо другой макет. В вашем случае страницы внутри /dashboard будут автоматически вложены в <Layout /> следующим образом:
Одним из преимуществ использования макетов в Next.js является то, что при навигации обновляются только компоненты страницы, а макет не перерисовывается. Это называется частичным рендерингом, который сохраняет состояние React на стороне клиента в макете при переходе между страницами.
Поскольку новый макет (/app/dashboard/layout.tsx), уникален для страниц дашборда, вам не нужно добавлять какой-либо пользовательский интерфейс в корневой макет выше.
----------
Корневой макет¶
В главе 3 вы импортировали шрифт Inter в другой макет: /app/layout.tsx.
Это называется корневой макет и требуется в каждом приложении Next.js. Любой пользовательский интерфейс, который вы добавите в корневой макет, будет общим для всех страниц вашего приложения
Вы можете использовать корневой макет для изменения тегов <html> и <body>, а также для добавления метаданных
Каково назначение файла layout в Next.js?
файл макета - это лучший способ создать общий макет, который могут использовать все страницы вашего приложения.

########################

Навигация между страницами
Как использовать компонент next/link.
Как показать активную ссылку с помощью хука usePathname().
Как работает навигация в Next.js.

В Next.js вы можете использовать компонент <Link /> для создания ссылок между страницами в вашем приложении.
компонент Link похож на использование тегов <a>, но вместо <a href="..."> вы используете <Link href="...">.
----------
Автоматическое разделение кода и предварительная выборка

Для улучшения навигации Next.js автоматически разделяет код вашего приложения по сегментам маршрута. Это отличается от традиционного React SPA, где браузер загружает весь код вашего приложения при начальной загрузке страницы.
в процессе работы, когда в области просмотра браузера появляются компоненты <Link>, Next.js автоматически загружают код для связанного маршрута в фоновом режиме.
-----------
Паттерн: Показ активных ссылок
активной ссылки, чтобы указать пользователю, на какой странице он находится в данный момент. Для этого необходимо получить текущий путь пользователя из URL. Next.js предоставляет хук usePathname(), который можно использовать для проверки пути и реализации этого паттерна.
Поскольку usePathname() - это хук React, работает только с директиву React "use client" в верхнюю часть файла
и превращает nav-links.tsx в клиентский компонент.

Импортируйте usePathname() из next/navigation:

   const pathname = usePathname();
 Вы можете использовать библиотеку clsx, представленную в главе CSS styling, для условного применения имен классов, когда ссылка активна. Когда link.href совпадает с pathname, ссылка должна отображаться с синим текстом и светло-голубым фоном.

 №№№№№№№№№№№№№№№№№№№№№№№№№№

 Настройка базы данных - глава -6
 В этой главе вы будете настраивать базу данных PostgreSQL из одного из Vercel's marketplace integrations.

1. Разместите свой проект на GitHub.
    В правом верхнем углу любой страницы выберите , затем нажмите Новый репозиторий.
    При желании добавьте описание своего репозитория. Например: «Мой первый репозиторий на GitHub».
    Выберите уровень доступа к репозиторию. Дополнительные сведения см. в разделе О репозиториях.
    Выберите Инициализировать этот репозиторий с помощью README.
    Нажмите Создать репозиторий
================
//делается один раз!! git-scm.com
git config --global user.name "Val115" - имя пользователя
git config --global user.email valfed38@yandex.ru  - мэил пользователя

echo "# git-project" >> README.md
=======================  .

echo "# test-next" >> README.md
----
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/val115/next-dashboard.git
git push -u origin main
-----------------
Команда git push -u origin main используется для отправки локального контента на GitHub. В коде origin — имя вашего удалённого репозитория по умолчанию, а флаг -u — upstream, что эквивалентно -set-upstream .
git-remote - Manage set of tracked repositories
git push -u origin main   - main - ветка (основная ветка)git
------------------
git status  - Show the working tree status (произошедшие изменения)
git add .	все файлы или git add --all
git commit -a
==================
Забор данных первым разработчиком
git fetch	-пересылаются данные в .git
git pull	-забор данных из .git
git log -5  (вывод 5 последнгих комитов ввиде жеского ресета)
no changes added to commit (use "git add" and/or "git commit -a")

git config --list
q  - выход в консоле из проги
=================
№№№№№№№№№№№№№№№№№№№№№№№№№№№№

2. Создайте учетную запись Vercel и свяжите с ней репозиторий GitHub для мгновенного предварительного просмотра и развертывания.
name - Valery
Посетите сайт vercel.com/signup, чтобы создать учетную запись. Выберите бесплатный тарифный план «Хобби». Выберите Continue with GitHub, чтобы соединить ваши аккаунты GitHub и Vercel.
Далее вы попадете на этот экран, где сможете выбрать и импортировать репозиторий GitHub, который вы только что создали:
Назовите свой проект и нажмите Deploy
next-dashboard
Подключив ваш репозиторий GitHub, при внесении изменений в вашу главную ветку Vercel будет автоматически развертывать ваше приложение без необходимости настройки. При открытии запросов на исправления у вас также будут URL мгновенного предварительного просмотра, которые позволят вам выявлять ошибки развертывания на ранней стадии и делиться предварительным просмотром проекта с членами команды для получения обратной связи.

3. Создайте и свяжите свой проект с базой данных Postgres.
Чтобы создать базу данных, нажмите
Continue to Dashboard  -      и выберите вкладку
    Storage -      на дашборде вашего проекта.
    Выберите Создать базу данных.
    Выберите предпочтительного поставщика - Neon или Supabase  - и нажмите Продолжить.
    Выберите регион и план хранения, если требуется. Регионом по умолчанию для всех проектов Vercel является Washington D.C (iad1)
    и мы рекомендуем выбрать его, если это возможно, чтобы уменьшить задержку для запросов данных.

После подключения перейдите на вкладку .env.local,
    нажмите Show secret и Copy Snippet - Убедитесь, что вы раскрыли секреты перед копированием.

Перейдите в редактор кода и переименуйте файл .env.example в .env. Вставьте в него скопированное содержимое из Vercel.

4. Наполните базу данных исходными данными.

Мы включили API, к которому вы можете получить доступ в браузере, который запустит начальный скрипт для заполнения базы данных начальным набором данных.

Скрипт - app/seed/route.ts - использует SQL для создания таблиц и данные из - placeholder-data.ts  - файла для их заполнения после создания.

Убедитесь, что ваш локальный сервер разработки работает, pnpm run devи перейдите наlocalhost:3000/seed  - в браузере. После завершения вы увидите сообщение «База данных успешно заполнена». После завершения вы можете удалить этот файл.

{"message":"Database seeded successfully"}
#################################

Глава 7
Извлечение данных
1. - Узнайте о некоторых подходах к извлечению данных: API, ORM, SQL и т. д.
2 - Как серверные компоненты могут помочь вам получить более безопасный доступ к внутренним ресурсам.
3 - Что такое сетевые водопады.
4 - Как реализовать параллельную выборку данных с использованием шаблона JavaScript.
===========
1. Выбор способа извлечения данных
  a - API — это промежуточный уровень между кодом вашего приложения и базой данных.
    API может пригодиться в нескольких случаях:
      Если вы используете сторонние сервисы, предоставляющие API.
      Если вы извлекаете данные из клиента, вам нужен уровень API, работающий на сервере, чтобы не раскрывать клиенту секреты вашей базы данных.
      В Next.js вы можете создавать конечные точки API с помощью обработчиков маршрутов .

Запросы к базе данных
При создании полнофункционального приложения вам также потребуется написать логику для взаимодействия с базой данных. Для реляционных баз данныхкак и в Postgres, вы можете сделать это с помощью SQL или ORM.

Есть несколько случаев, когда вам придется писать запросы к базе данных:

При создании конечных точек API вам необходимо написать логику взаимодействия с базой данных.
Если вы используете компоненты React - Server (извлекающие данные на сервере), вы можете пропустить уровень API и выполнять запросы к базе данных напрямую, не рискуя раскрыть секреты базы данных клиенту.
----------------
Использование SQL
Для вашего приложения панели управления вы будете писать запросы к базе данных, используя postgres.jsБиблиотека и SQL. Есть несколько причин, по которым мы будем использовать SQL:

- SQL — это отраслевой стандарт для запросов к реляционным базам данных (например, ORM генерируют SQL «под капотом»).
- Базовые знания SQL помогут вам понять основы реляционных баз данных, что позволит вам применять свои знания и в других инструментах.
- SQL универсален и позволяет извлекать и обрабатывать определенные данные.

Перейдите по ссылке /app/lib/data.ts. Здесь вы увидите, что мы используем функциюpostgres .sql позволяет вам делать запросы к вашей базе данных:
import postgres from 'postgres';
const sql = postgres(process.env.POSTGRES_URL!, { ssl: 'require' });

Вы можете вызывать sqlлюбой объект на сервере, например, компонент сервера. Но для облегчения навигации по компонентам мы сохранили все запросы к данным в data.tsфайле, и вы можете импортировать их в компоненты.
=================
Использование серверных компонентов для получения данных
  Серверные компоненты поддерживают JavaScript Promises, предоставляя решение для асинхронных задач,
таких как извлечение данных изначально. Вы можете использовать async/await синтаксис,
не прибегая к useEffect, useState или другим библиотекам извлечения данных.
  Серверные компоненты работают на сервере, поэтому вы можете выполнять дорогостоящие операции
по извлечению данных и логические операции на сервере, отправляя клиенту только результат.
  Поскольку серверные компоненты работают на сервере, вы можете напрямую обращаться
к базе данных без  дополнительного уровня API. Это избавляет вас от необходимости писать
и поддерживать дополнительный код.



============
Извлечение данных для страницы обзора панели мониторинга
Теперь, когда вы знакомы с различными способами получения данных, давайте извлечём данные для страницы обзора панели мониторинга. Перейдите по адресу /app/dashboard/page.tsx, вставьте следующий код и изучите его:

Приведённый выше код намеренно закомментирован. Теперь мы рассмотрим каждый фрагмент по отдельности.
page — это асинхронный серверный компонент. Это позволяет использовать await для получения данных.
Есть также три компонента, которые получают данные: <Card>, <RevenueChart>, и <LatestInvoices>. В настоящее время они закомментированы и ещё не реализованы.
==================
Выборка данных для <RevenueChart/>
Чтобы получить данные для компонента <RevenueChart/>, импортируйте функцию fetchRevenue из data.ts и вызовите её внутри своего компонента:


