https://nextjs.org/learn/dashboard-app/getting-started

https://reactdev.ru/libs/nextjs/app-router/fetching-data/#_5

https://reactdev.ru/libs/nextjs/app-router/setting-up-your-database/
===============

npm install -g pnpm
npx create-next-app@latest nextjs-dashboard --example "https://github.com/vercel/next-learn/tree/main/dashboard/starter-example" --use-pnpm
pnpm dev
 ----------

https://reactdev.ru/libs/nextjs/app-router/css-styling/#_2
Стили
Два разных способа стилизации: Tailwind и CSS-модули.
global.css. Этот файл можно использовать для добавления правил CSS для всех маршрутов в вашем приложении,
Вы можете импортировать global.css в любой компонент вашего приложения, но обычно рекомендуется добавлять его в компонент верхнего уровня. В Next. js
global.css, вы заметите некоторые @tailwind (Попутный ветер)  директивы:
В Tailwind вы стилизуете элементы, добавляя имена классов. Например, добавление "text-blue-500" сделает текст <h1> синим:
=======================
clsx Это библиотека,
https://github.com/lukeed/clsx

 которая позволяет легко переключать имена классов. Мы рекомендуем ознакомиться с документацией для получения более подробной информации, но вот базовый пример использования:
axemple (фактура) - app/ui/invoices/status.tsx
===============================
#cd nextjs-dashboard
Для этого проекта мы предоставили некоторые данные-заполнители в app/lib/placeholder-data.ts. Каждый объект JavaScript в файле представляет собой таблицу в вашей базе данных. Например, для таблицы счетов-фактур:
А пока взгляните на файл /app/lib/definitions.ts . Здесь мы вручную определяем типы данных, которые будут возвращаться из базы данных.
 Мы вручную указываем типы данных, но для большей безопасности рекомендуем использовать Prisma или Drizzle, которые автоматически генерируют типы на основе схемы вашей базы данных.
 ####################

Шрифты играют важную роль в дизайне сайта, но использование пользовательских шрифтов в вашем проекте может повлиять на производительность, файлы шрифтов должны быть получены и загружены.
Cumulative Layout Shift - это метрика, используемая Google для оценки производительности и удобства работы с сайтом
Next.js автоматически оптимизирует шрифты в приложении, когда вы используете
модуль next/font.
Он загружает файлы шрифтов во время сборки и размещает их вместе с другими статическими активами. Это означает, что когда пользователь посещает ваше приложение, не происходит дополнительных сетевых запросов к шрифтам, которые могут влиять на производительность.
Next.js загружает файлы шрифтов во время сборки и размещает их вместе с другими статическими активами. Это означает, что когда пользователь посещает ваше приложение, нет никаких дополнительных сетевых запросов к шрифтам, которые могли бы повлиять на производительность.
----------
В папке /app/ui создайте новый файл fonts.ts.
Импортируйте шрифт Inter из модуля next/font/google -
Затем укажите, какое подмножество вы хотите загрузить. В данном случае 'latin':
/app/layout.tsx
import '@/app/ui/global.css';
import { inter } from '@/app/ui/fonts';
<body  className={`${inter.className} antialiased`} >
класс Tailwind antialiased, который сглаживает шрифт. Использовать этот класс необязательно, но он добавляет приятный штрих.

Вы также можете добавить шрифты к определенным элементам вашего приложения.
В файле fonts.ts импортируйте вторичный шрифт Lusitana и передайте его элементу <p> в файле /app/page.tsx. В дополнение к указанию подмножества,  вы также должны указать различные веса шрифта. Например, 400 (нормальный) и 700 (жирный).
Наконец, компонент <AcmeLogo /> также использует Lusitana. Он был закомментирован для предотвращения ошибок, теперь его можно не комментировать:
##############

Next.js может обслуживать статические активы, такие как изображения, в папке верхнего уровня /public.
Однако это означает, что вам придется работать вручную:

1. Убедиться, что изображение реагирует на разные размеры экрана.
2. Задать размеры изображений для разных устройств.
3. Предотвратить смещение макета при загрузке изображений.
4. Ленивая загрузка изображений, которые находятся вне области просмотра пользователя.

Компонент <Image> является расширением тега HTML <img>
 включает в себя автоматическую оптимизацию изображений, такую как:
1. Предотвращение автоматического смещения макета при загрузке изображений.
2. Изменение размера изображений, чтобы избежать отправки больших изображений на     устройства с меньшей областью просмотра.
3. Ленивая загрузка изображений по умолчанию (изображения загружаются по мере их попадания в область просмотра).
4. Использование изображений в современных форматах, таких как WebP и AVIF, если браузер поддерживает их.
В файле /app/page.tsx импортируйте компонент из next/image. Затем добавьте изображение под комментарием:

import Image from 'next/image';

Вы также заметите класс hidden, чтобы убрать изображение из DOM на мобильных экранах, и md:block, чтобы показать его на настольных экранах.

Добавление основного изображения для мобильных устройств
Под основным изображением, которое вы только что добавили, добавьте еще один компонент <Image> для hero-mobile.png.
Это изображение должно иметь width в 560 и height в 620 пикселей.
Оно должно быть показано на мобильных экранах и скрыто на десктопе - вы можете использовать инструменты dev, чтобы проверить, правильно ли поменялись местами десктопные и мобильные изображения.

##########################

Создание макетов и страниц
Вы можете создавать отдельные пользовательские интерфейсы для каждого маршрута с помощью файлов layout.tsx и page.tsx.
page.tsx - это специальный файл Next.js, который экспортирует компонент React, и он необходим для того, чтобы маршрут был доступен.
/app/dashboard/page.tsx ассоциируется с путем /dashboard.
Благодаря специальному названию для файлов page Next.js позволяет размещать компоненты пользовательского интерфейса, тестовые файлы и другой связанный код вместе с маршрутами. Только содержимое внутри файла page будет общедоступным. Например, папки /ui и /lib размещаются внутри папки /app вместе с маршрутами.

В вашем дашборде создайте еще две страницы:
 Страница клиентов: Страница должна быть доступна по адресу - customers
  Страница счетов: Страница счетов должна быть доступна по адресу - invoices

Дашборды имеют некую навигацию, которая используется на нескольких страницах. В Next.js вы можете использовать специальный файл layout.tsx для создания пользовательского интерфейса, разделяемого между несколькими страницами. Давайте создадим макет для страниц дашборда!
Во-первых, вы импортируете компонент <SideNav /> в ваш макет. Все компоненты, которые вы импортируете в этот файл, будут частью макета.
Компонент <Layout /> получает свойство children. Этим дочерним компонентом может быть либо страница, либо другой макет. В вашем случае страницы внутри /dashboard будут автоматически вложены в <Layout /> следующим образом:
Одним из преимуществ использования макетов в Next.js является то, что при навигации обновляются только компоненты страницы, а макет не перерисовывается. Это называется частичным рендерингом, который сохраняет состояние React на стороне клиента в макете при переходе между страницами.
Поскольку новый макет (/app/dashboard/layout.tsx), уникален для страниц дашборда, вам не нужно добавлять какой-либо пользовательский интерфейс в корневой макет выше.
----------
Корневой макет¶
В главе 3 вы импортировали шрифт Inter в другой макет: /app/layout.tsx.
Это называется корневой макет и требуется в каждом приложении Next.js. Любой пользовательский интерфейс, который вы добавите в корневой макет, будет общим для всех страниц вашего приложения
Вы можете использовать корневой макет для изменения тегов <html> и <body>, а также для добавления метаданных
Каково назначение файла layout в Next.js?
файл макета - это лучший способ создать общий макет, который могут использовать все страницы вашего приложения.

########################

Навигация между страницами
Как использовать компонент next/link.
Как показать активную ссылку с помощью хука usePathname().
Как работает навигация в Next.js.

В Next.js вы можете использовать компонент <Link /> для создания ссылок между страницами в вашем приложении.
компонент Link похож на использование тегов <a>, но вместо <a href="..."> вы используете <Link href="...">.
----------
Автоматическое разделение кода и предварительная выборка

Для улучшения навигации Next.js автоматически разделяет код вашего приложения по сегментам маршрута. Это отличается от традиционного React SPA, где браузер загружает весь код вашего приложения при начальной загрузке страницы.
в процессе работы, когда в области просмотра браузера появляются компоненты <Link>, Next.js автоматически загружают код для связанного маршрута в фоновом режиме.
-----------
Паттерн: Показ активных ссылок
активной ссылки, чтобы указать пользователю, на какой странице он находится в данный момент. Для этого необходимо получить текущий путь пользователя из URL. Next.js предоставляет хук usePathname(), который можно использовать для проверки пути и реализации этого паттерна.
Поскольку usePathname() - это хук React, работает только с директиву React "use client" в верхнюю часть файла
и превращает nav-links.tsx в клиентский компонент.

Импортируйте usePathname() из next/navigation:

   const pathname = usePathname();
 Вы можете использовать библиотеку clsx, представленную в главе CSS styling, для условного применения имен классов, когда ссылка активна. Когда link.href совпадает с pathname, ссылка должна отображаться с синим текстом и светло-голубым фоном.

 №№№№№№№№№№№№№№№№№№№№№№№№№№

 Настройка базы данных - глава -6
 В этой главе вы будете настраивать базу данных PostgreSQL из одного из Vercel's marketplace integrations.

1. Разместите свой проект на GitHub.
    В правом верхнем углу любой страницы выберите , затем нажмите Новый репозиторий.
    При желании добавьте описание своего репозитория. Например: «Мой первый репозиторий на GitHub».
    Выберите уровень доступа к репозиторию. Дополнительные сведения см. в разделе О репозиториях.
    Выберите Инициализировать этот репозиторий с помощью README.
    Нажмите Создать репозиторий
================
//делается один раз!! git-scm.com
git config --global user.name "Val115" - имя пользователя
git config --global user.email valfed38@yandex.ru  - мэил пользователя

echo "# git-project" >> README.md
=======================  .

echo "# test-next" >> README.md
----
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/val115/next-dashboard.git
git push -u origin main
-----------------
Команда git push -u origin main используется для отправки локального контента на GitHub. В коде origin — имя вашего удалённого репозитория по умолчанию, а флаг -u — upstream, что эквивалентно -set-upstream .
git-remote - Manage set of tracked repositories
git push -u origin main   - main - ветка (основная ветка)git
------------------
git status  - Show the working tree status (произошедшие изменения)
git add .	все файлы или git add --all
git commit -a
==================
Забор данных первым разработчиком
git fetch	-пересылаются данные в .git
git pull	-забор данных из .git
git log -5  (вывод 5 последнгих комитов ввиде жеского ресета)
no changes added to commit (use "git add" and/or "git commit -a")

git config --list
q  - выход в консоле из проги
=================
№№№№№№№№№№№№№№№№№№№№№№№№№№№№

2. Создайте учетную запись Vercel и свяжите с ней репозиторий GitHub для мгновенного предварительного просмотра и развертывания.
name - Valery
Посетите сайт vercel.com/signup, чтобы создать учетную запись. Выберите бесплатный тарифный план «Хобби». Выберите Continue with GitHub, чтобы соединить ваши аккаунты GitHub и Vercel.
Далее вы попадете на этот экран, где сможете выбрать и импортировать репозиторий GitHub, который вы только что создали:
Назовите свой проект и нажмите Deploy
next-dashboard
Подключив ваш репозиторий GitHub, при внесении изменений в вашу главную ветку Vercel будет автоматически развертывать ваше приложение без необходимости настройки. При открытии запросов на исправления у вас также будут URL мгновенного предварительного просмотра, которые позволят вам выявлять ошибки развертывания на ранней стадии и делиться предварительным просмотром проекта с членами команды для получения обратной связи.

3. Создайте и свяжите свой проект с базой данных Postgres.
Чтобы создать базу данных, нажмите
Continue to Dashboard  -      и выберите вкладку
    Storage -      на дашборде вашего проекта.
    Выберите Создать базу данных.
    Выберите предпочтительного поставщика - Neon или Supabase  - и нажмите Продолжить.
    Выберите регион и план хранения, если требуется. Регионом по умолчанию для всех проектов Vercel является Washington D.C (iad1)
    и мы рекомендуем выбрать его, если это возможно, чтобы уменьшить задержку для запросов данных.

После подключения перейдите на вкладку .env.local,
    нажмите Show secret и Copy Snippet - Убедитесь, что вы раскрыли секреты перед копированием.

Перейдите в редактор кода и переименуйте файл .env.example в .env. Вставьте в него скопированное содержимое из Vercel.

4. Наполните базу данных исходными данными.

Мы включили API, к которому вы можете получить доступ в браузере, который запустит начальный скрипт для заполнения базы данных начальным набором данных.

Скрипт - app/seed/route.ts - использует SQL для создания таблиц и данные из - placeholder-data.ts  - файла для их заполнения после создания.

Убедитесь, что ваш локальный сервер разработки работает, pnpm run devи перейдите наlocalhost:3000/seed  - в браузере. После завершения вы увидите сообщение «База данных успешно заполнена». После завершения вы можете удалить этот файл.

{"message":"Database seeded successfully"}
#################################

Глава 7
Извлечение данных
1. - Узнайте о некоторых подходах к извлечению данных: API, ORM, SQL и т. д.
2 - Как серверные компоненты могут помочь вам получить более безопасный доступ к внутренним ресурсам.
3 - Что такое сетевые водопады.
4 - Как реализовать параллельную выборку данных с использованием шаблона JavaScript.
===========
1. Выбор способа извлечения данных
  a - API — это промежуточный уровень между кодом вашего приложения и базой данных.
    API может пригодиться в нескольких случаях:
      Если вы используете сторонние сервисы, предоставляющие API.
      Если вы извлекаете данные из клиента, вам нужен уровень API, работающий на сервере, чтобы не раскрывать клиенту секреты вашей базы данных.
      В Next.js вы можете создавать конечные точки API с помощью обработчиков маршрутов .

Запросы к базе данных
При создании полнофункционального приложения вам также потребуется написать логику для взаимодействия с базой данных. Для реляционных баз данныхкак и в Postgres, вы можете сделать это с помощью SQL или ORM.

Есть несколько случаев, когда вам придется писать запросы к базе данных:

При создании конечных точек API вам необходимо написать логику взаимодействия с базой данных.
Если вы используете компоненты React - Server (извлекающие данные на сервере), вы можете пропустить уровень API и выполнять запросы к базе данных напрямую, не рискуя раскрыть секреты базы данных клиенту.
----------------
Использование SQL
Для вашего приложения панели управления вы будете писать запросы к базе данных, используя postgres.jsБиблиотека и SQL. Есть несколько причин, по которым мы будем использовать SQL:

- SQL — это отраслевой стандарт для запросов к реляционным базам данных (например, ORM генерируют SQL «под капотом»).
- Базовые знания SQL помогут вам понять основы реляционных баз данных, что позволит вам применять свои знания и в других инструментах.
- SQL универсален и позволяет извлекать и обрабатывать определенные данные.

Перейдите по ссылке /app/lib/data.ts. Здесь вы увидите, что мы используем функциюpostgres .sql позволяет вам делать запросы к вашей базе данных:

Вы можете вызывать sqlлюбой объект на сервере, например, компонент сервера. Но для облегчения навигации по компонентам мы сохранили все запросы к данным в data.tsфайле, и вы можете импортировать их в компоненты.

========Получение данных для страницы обзора дашборда====
Теперь, когда вы знакомы с различными способами получения данных, давайте извлечём данные для страницы обзора панели мониторинга. Перейдите по адресу /app/dashboard/page.tsx, вставьте следующий код и изучите его:

import { Card } from '@/app/ui/dashboard/cards';
import RevenueChart from '@/app/ui/dashboard/revenue-chart';
import LatestInvoices from '@/app/ui/dashboard/latest-invoices';
import { lusitana } from '@/app/ui/fonts';

export default async function Page() {
    return (
        <main>
            <h1
                className={`${lusitana.className} mb-4 text-xl md:text-2xl`}
            >
                Dashboard
            </h1>
            <div className="grid gap-6 sm:grid-cols-2 lg:grid-cols-4">
                {/* <Card title="Collected" value={totalPaidInvoices} type="collected" /> */}
                {/* <Card title="Pending" value={totalPendingInvoices} type="pending" /> */}
                {/* <Card title="Total Invoices" value={numberOfInvoices} type="invoices" /> */}
                {/* <Card
          title="Total Customers"
          value={numberOfCustomers}
          type="customers"
        /> */}
            </div>
            <div className="mt-6 grid grid-cols-1 gap-6 md:grid-cols-4 lg:grid-cols-8">
                {/* <RevenueChart revenue={revenue}  /> */}
                {/* <LatestInvoices latestInvoices={latestInvoices} /> */}
            </div>
        </main>
    );
}
==========
page - это серверный компонент async. Он позволяет использовать await для получения данных.
Также есть 3 компонента, которые получают данные: <Card>, <RevenueChart> и <LatestInvoices>. В настоящее время они закомментированы и пока не реализованы.
----------------
Получение данных для <RevenueChart/>

import { fetchRevenue } from '@/app/lib/data';

export default async function Page() {
    const revenue = await fetchRevenue();
-----------
Далее сделаем следующее:
Откомментируйте компонент <RevenueChart/>.
Перейдите к файлу компонента (/app/ui/dashboard/revenue-chart.tsx) и откомментируйте код внутри него.
Проверьте localhost:3000 и вы должны увидеть график, использующий данные revenue.

======Получение данных для <LatestInvoices/>============

Для компонента <LatestInvoices /> нам нужно получить 5 последних счетов-фактур, отсортированных по дате.

Вы можете получить все счета и отсортировать их с помощью JavaScript. Это не
 проблема, поскольку наши данные невелики, но по мере роста вашего приложения 
 может значительно увеличиться объем данных, передаваемых при каждом запросе, 
 и JavaScript, необходимый для их сортировки.

Вместо того чтобы сортировать последние счета в памяти, вы можете использовать 
SQL-запрос, чтобы получить только 5 последних счетов. Например, вот SQL-запрос 
из вашего файла data.ts:

import {
    fetchRevenue,
    fetchLatestInvoices,
} from '@/app/lib/data';

export default async function Page() {
    const revenue = await fetchRevenue();
    const latestInvoices = await fetchLatestInvoices()
  -------------
    Затем откомментируйте компонент <LatestInvoices />. Вам также нужно будет откомментировать соответствующий код в самом компоненте <LatestInvoices />, расположенном по адресу /app/ui/dashboard/latest-invoices.

    ========= Практика: Получение данных для компонентов <Card>===============

Теперь настала ваша очередь получить данные для компонентов <Card>. На карточках будут отображаться следующие данные:

Общая сумма собранных счетов.
Общая сумма счетов, ожидающих оплаты.
Общее количество счетов-фактур.
Общее количество клиентов.
Опять же, у вас может возникнуть соблазн получить все счета и клиентов и использовать JavaScript для работы с данными. Например, вы можете использовать Array.length для получения общего количества счетов и клиентов:

const totalInvoices = allInvoices.length;
const totalCustomers = allCustomers.length;

Но с помощью SQL вы можете получить только те данные, которые вам нужны. 
Это немного дольше, чем использование Array.length, но это означает, 
что во время запроса нужно передать меньше данных. Это альтернатива SQL:

Функция, которую вам нужно импортировать, называется fetchCardData. 
Вам нужно будет деструктурировать значения, возвращаемые функцией.
----------------
Однако... есть две вещи, о которых вы должны знать:

1. Запросы данных непреднамеренно блокируют друг друга, создавая водопад запросов.
2. По умолчанию Next.js предусматривает маршруты для повышения производительности,
это называется Static Rendering. Таким образом, если ваши данные изменятся, 
они не будут отражены в дашборде.

Давайте обсудим номер 1 в этой главе, а затем подробно рассмотрим номер 2 в следующей главе.
Что такое водопады запросов?
«Водопад» — это последовательность сетевых запросов, зависящая от завершения
предыдущих запросов. В случае выборки данных каждый запрос может начаться
только после того, как предыдущий запрос вернул данные.

const revenue = await fetchRevenue();
const latestInvoices = await fetchLatestInvoices(); // wait for fetchRevenue() to finish
const {
  numberOfInvoices,
  numberOfCustomers,
  totalPaidInvoices,
  totalPendingInvoices,
} = await fetchCardData(); // wait for fetchLatestInvoices() to finish

Этот шаблон не обязательно плох. В некоторых случаях водопады могут быть полезны,
поскольку требуется, чтобы условие было выполнено до выполнения следующего запроса.
Например, сначала может потребоваться получить идентификатор и информацию из профиля
пользователя. Получив идентификатор, можно перейти к получению списка его друзей.
В этом случае каждый запрос зависит от данных, возвращенных предыдущим запросом.
===================

Параллельная выборка данных
Распространенный способ избежать водопадов — инициировать все запросы к данным
одновременно, то есть параллельно.

В JavaScript вы можете использовать Promise.all() или Promise.allSettled() Функции для
одновременной инициации всех обещаний. Например, в data.ts, мы используем
Promise.all() функцию fetchCardData():
export async function fetchCardData() {
  try {
    const invoiceCountPromise = sql`SELECT COUNT(*) FROM invoices`;
    const customerCountPromise = sql`SELECT COUNT(*) FROM customers`;
    const invoiceStatusPromise = sql`SELECT
         SUM(CASE WHEN status = 'paid' THEN amount ELSE 0 END) AS "paid",
         SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END) AS "pending"
         FROM invoices`;
const data = await Promise.all([
      invoiceCountPromise,
      customerCountPromise,
      invoiceStatusPromise,
    ]);
  }}
В этом случае
Начните выполнять все выборки данных одновременно, что быстрее, чем ждать
завершения каждого запроса в каскадной модели.
Используйте собственный шаблон JavaScript, который можно применить к любой
библиотеке или фреймворку.
Однако использование только этого шаблона JavaScript имеет один недостаток :
что произойдёт, если один запрос данных окажется медленнее всех остальных?
Подробнее об этом мы поговорим в следующей главе.

№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№№

Глава 8
Статический и динамический рендеринг

1 - Что такое статический рендеринг и как он может улучшить производительность
вашего приложения.
2 - Что такое динамический рендеринг и когда его использовать.
3 - Различные подходы к созданию динамичной панели управления.
4 - Смоделируйте медленную выборку данных, чтобы увидеть, что произойдет.

1 - Что такое статический рендеринг?
При статическом рендеринге извлечение и рендеринг данных происходят на сервере
во время сборки (при развертывании) или при повторной проверке данных .

При каждом посещении вашего приложения пользователем отображается кешированный
результат. Статический рендеринг имеет ряд преимуществ:
- Более быстрые веб-сайты — предварительно отрендеренный контент может кэшироваться
и распространяться по всему миру при размещении на таких платформах, как Vercel.
Это позволяет пользователям по всему миру быстрее и надёжнее получать доступ к
контенту вашего сайта.
- Снижение нагрузки на сервер — поскольку контент кэшируется, серверу не нужно
динамически генерировать контент для каждого запроса пользователя. Это позволяет
сократить расходы на вычисления.
- SEO — поисковым роботам проще индексировать предварительно отрендеренный контент,
поскольку он уже доступен при загрузке страницы. Это может привести к повышению
рейтинга в поисковых системах.
Статический рендеринг полезен для пользовательского интерфейса с отсутствием данных
или данными, которые являются общими для всех пользователей, например для статического
поста в блоге или страницы продукта. Он может не подойти для панели управления с
персонализированными данными, которые регулярно обновляются.
-----------------

2 - Противоположностью статическому рендерингу является динамический рендеринг.
При динамическом рендеринге контент отображается на сервере для каждого пользователя в 
момент запроса (когда пользователь заходит на страницу). У динамического рендеринга 
есть несколько преимуществ:
- Данные в реальном времени — динамический рендеринг позволяет вашему приложению
отображать данные в реальном времени или часто обновляемые данные. Это идеальный
вариант для приложений, в которых данные часто меняются.
- Контент для конкретного пользователя — так проще предоставлять персонализированный
контент, например информационные панели или профили пользователей, и обновлять данные
в зависимости от действий пользователя.
- Информация о времени запроса — динамический рендеринг позволяет получить доступ к
информации, которая может быть известна только во время запроса, например к файлам
cookie или параметрам поиска в URL.

3 - Имитация медленной загрузки данных
- Приложение для панели управления, которое мы разрабатываем, является динамическим.
- Однако в предыдущей главе упоминалась ещё одна проблема. Что произойдёт, если один
 запрос данных будет выполняться медленнее остальных?
- Давайте смоделируем медленную загрузку данных. В app/lib/data.ts раскомментируйте
 console.log и setTimeout внутри fetchRevenue():

При динамическом рендеринге скорость работы вашего приложения зависит от
скорости получения данных.

========= 9 - Потоковое вещание =============
 Давайте посмотрим, как можно улучшить взаимодействие с пользователем при
 медленной загрузке данных.

- Что такое стриминг и в каких случаях его можно использовать.
- Как реализовать потоковую передачу с помощью loading.tsx и Suspense.
- Что такое нагрузочные скелеты.
- Что такое группы маршрутов в Next. js и в каких случаях их можно использовать.
- Где в приложении следует размещать границы React Suspense.

- Что такое потоковое передача---------?
Потоковая передача — это метод передачи данных, который позволяет разбивать маршрут
на более мелкие «фрагменты» и постепенно передавать их с сервера клиенту по мере
готовности.
Благодаря потоковой передаче данных вы можете предотвратить блокировку всей страницы
из-за медленных запросов данных. Это позволяет пользователю видеть части страницы
и взаимодействовать с ними, не дожидаясь полной загрузки данных перед отображением
 пользовательского интерфейса.

Стриминг хорошо сочетается с компонентной моделью React, поскольку каждый компонент
можно рассматривать как фрагмент.

В Next. js есть два способа реализации потоковой передачи:
1- На уровне страницы с помощью файла loading.tsx (который создает <Suspense> для вас).
2- На уровне компонента используйте <Suspense> для более детального управления.
===============


---Потоковая передача целой страницы с loading.tsx ---
В папке /app/dashboard создайте новый файл под названием loading.tsx:
export default function Loading() {
  return <div>Loading...</div>;
}

1- loading.tsx - Это специальный файл Next. js, созданный на основе React Suspense.
Он позволяет создавать резервный пользовательский интерфейс, который будет
отображаться вместо основного во время загрузки содержимого страницы.
2 - Поскольку <SideNav> является статическим элементом, он отображается сразу. Пользователь может взаимодействовать с <SideNav> во время загрузки динамического
контента.
3- Пользователю не нужно ждать, пока страница загрузится, чтобы перейти на другую
(это называется прерывистой навигацией).

Поздравляем! Вы только что внедрили потоковую передачу. Но мы можем сделать ещё
больше, чтобы улучшить пользовательский опыт. Давайте вместо Loading… текста
будем показывать индикатор загрузки.

------- Добавление скелетонов загрузки  ----
Скелет загрузки — это упрощённая версия пользовательского интерфейса. Многие веб-сайты 
используют их в качестве заполнителя (или запасного варианта), чтобы показать пользователям, 
что контент загружается. Любой пользовательский интерфейс, который вы добавите в loading.tsx, 
будет встроен в статический файл и отправлен первым. Затем с сервера на клиент 
будет передаваться остальной динамический контент.

В файле loading.tsx импортируйте новый компонент под названием <DashboardSkeleton>:
/app/dashboard/loading.tsx

import DashboardSkeleton from '@/app/ui/skeletons';

export default function Loading() {
  return <DashboardSkeleton />;
}

---------Исправление ошибки скелета загрузки с группами маршрутов-------
Устранение ошибки с загрузкой скелета с помощью групп маршрутов
Прямо сейчас ваш шаблон загрузки будет применяться к счетам.

Поскольку loading.tsx находится на уровень выше, чем /invoices/page.tsx 
и /customers/page.tsx в файловой системе, это правило применяется и к 
этим страницам.

Мы можем изменить это с помощью групп маршрутов (RouteGroups). Создайте новую папку 
под названием /(overview) - внутри папки dashboard. 
Затем переместите файлы loading.tsx и page.tsx в эту папку:

Теперь файл loading.tsx будет применяться только на странице обзора вашей панели управления.

Группы маршрутов позволяют объединять файлы в логические группы без изменения 
структуры URL-адреса. При создании новой папки с помощью скобок () её название 
не будет включаться в URL-адрес. Таким образом, /dashboard/(overview)/page.tsx 
становится /dashboard.

Здесь вы используете группу маршрутов, чтобы loading.tsx применялся только 
на странице обзора панели управления. Однако вы также можете использовать 
группы маршрутов, чтобы разделить приложение на разделы (например, (marketing) 
и (shop) маршруты) или по командам для более крупных приложений.

---------- Потоковая передача компонента -------
Пока что вы транслируете целую страницу. Но вы также можете транслировать отдельные 
компоненты с помощью React Suspense.

Suspense позволяет отложить рендеринг частей приложения до выполнения какого-либо 
условия (например, загрузки данных). Вы можете обернуть свои динамические компоненты 
в Suspense. Затем передайте ему резервный компонент, который будет отображаться во 
время загрузки динамического компонента.

Если вы помните, что запрос данных выполняется медленно, fetchRevenue(), то именно 
этот запрос замедляет работу всей страницы. Вместо того чтобы блокировать всю страницу, 
вы можете использовать Suspense для потоковой передачи данных только для этого компонента 
и сразу же отобразить остальную часть пользовательского интерфейса страницы.

Для этого вам нужно перенести получение данных в компонент. Давайте обновим код и посмотрим, как это будет выглядеть:

Удалите все экземпляры fetchRevenue() и их данные из 
/dashboard/(overview)/page.tsx:

Затем импортируйте <Suspense> из React и оберните его в <RevenueChart />. 
Вы можете передать ему резервный компонент под названием <RevenueChartSkeleton>.

Наконец, обновите компонент <RevenueChart>, чтобы он получал собственные данные,
и удалите переданное ему свойство:
/app/ui/dashboard/revenue-chart.tsx

Теперь обновите страницу, и вы почти сразу увидите информацию на панели управления, а для <RevenueChart> будет отображаться резервный шаблон:

=========  Практика: Потоковое вещание <LatestInvoices>   ==============

Теперь ваша очередь! Отработайте то, чему вы только что научились, 
выполнив потоковую передачу компонента <LatestInvoices>.

Переместите fetchLatestInvoices() вниз со страницы на компонент <LatestInvoices>. Заверните компонент в границу <Suspense> с фаллабетом <LatestInvoicesSkeleton>.

/app/dashboard/(overview)/page.tsx

<LatestInvoices> component. Remember to remove the props from the component:
/app/ui/dashboard/latest-invoices.tsx

===========  Группировка компонентов  ==================

Отлично! Вы почти у цели, теперь вам нужно обернуть компоненты <Card> 
в Suspense. Вы можете получить данные для каждой отдельной карты, 
но это может привести к эффекту «выпрыгивания» при загрузке карт, 
что может визуально раздражать пользователя.

Как же решить эту проблему?

Чтобы создать эффект «ступенчатости», вы можете сгруппировать карточки 
с помощью компонента-обертки. Это означает, что сначала будет показан 
статический <SideNav/>, затем карточки и т. д.

В файле page.tsx:

- Удалите компоненты <Card>.
- Удалите функцию fetchCardData().
- Импортируйте новый компонент обертки под названием <CardWrapper />.
- Импортируйте новый скелетон компонента под названием <CardsSkeleton />.
- Оберните <CardWrapper /> в Suspense.

/app/dashboard/(overview)/page.tsx

Затем перейдите в файл /app/ui/dashboard/cards.tsx, импортируйте функцию
fetchCardData() и вызовите ее внутри компонента <CardWrapper/>. 
Не забудьте откомментировать весь необходимый код в этом компоненте.

/app/ui/dashboard/cards.tsx

// ...
import { fetchCardData } from '@/ap

---
Обновите страницу, и вы увидите, что все карты загружаются одновременно. Вы можете использовать этот шаблон, когда хотите, чтобы несколько компонентов загружались одновременно.























